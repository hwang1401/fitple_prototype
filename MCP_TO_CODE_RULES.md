# MCP → Code 변환 규칙 (논점 고정용)

이 문서는 “MCP에서 얻은 정보를 왜 그대로 구현 못했는가?”에 대한 **원인/해결/예방 규칙**을 고정한다.  
이후 작업은 **이 문서의 규칙을 벗어나지 않는다.**

---

## 0) 이 문서의 논점 (고정)

**논점**: “MCP가 준 정보를 ‘그대로’ 코드에 적용하지 못한 이유는 무엇이며, 다시는 그 실수를 하지 않기 위한 규칙은 무엇인가?”

- 이 문서는 “상태 모델링/기획” 논의로 넘어가지 않는다.
- 이후 변경은 **MCP에서 확인된 값/타입/구조를 코드에 그대로 반영**하는 관점에서만 이뤄진다.

---

## 1) MCP가 주는 정보 (팩트)

- **레이아웃/구조 값**: Auto Layout 기반의 flex/stack 구조, gap/padding/width/height
- **타이포 값**: font-size/weight/line-height/letter-spacing
- **색상 값**: fill/stroke/background/opacity (토큰/직접값)
- **컴포넌트 힌트**: Figma 레이어/컴포넌트 이름(예: `primary button/filled/text+icon`)
- **아이콘 결과(appearance)**: 디자인에서 “흰색으로 보이는지/빨간색으로 보이는지” 같은 결과

---

## 2) MCP가 자동으로 해주지 않는 것 (팩트)

### 2.1 프로젝트 컴포넌트 매핑
MCP는 “이게 `primary filled`다” 같은 힌트는 주지만, 이를 **우리 코드의 어떤 클래스(`btn-pfti--lg` 등)**로 쓸지 자동 결정하지 않는다.

### 2.2 로컬 에셋(assets) 매핑
MCP는 Figma 내부 SVG(= localhost 링크)로 주는 경우가 많다.  
이를 **`assets/에셋/...`의 어떤 파일로 교체할지**는 자동으로 못 고른다.

### 2.3 Override 기반 색상 적용(아이콘 색상 포함)
Figma/MCP는 아이콘이 “흰색으로 보인다” 같은 **결과(appearance)**를 준다.  
하지만 로컬 에셋이 `fill="#5C5C5C"`처럼 **색이 고정된 SVG**이고 `<img>`로 렌더링하면, 그 결과를 CSS로 그대로 바꾸기 어렵다.  
따라서 “MCP 결과 그대로”를 만족하려면 **렌더링 방식/에셋 정책**이 필요하다(§6).

---

## 3) 왜 “그대로”가 깨졌는가 (원인 고정)

### 원인 A: 변환/매핑 단계에서 실수
- 존재하지 않는 클래스 사용(예: CSS에 없는 버튼 클래스)
- 컴포넌트 마크업 규칙 무시(체크박스 구조 불일치 → 이중 체크/포커스 이상)
- 전역 레이아웃 클래스와 불일치(정의 없는 `.header-left` 등)

### 원인 B: 에셋/렌더링 방식 차이
- Figma는 “화이트 아이콘”처럼 보이지만, 로컬 SVG가 회색으로 고정이면 `<img>`로는 색을 못 바꿈

---

## 4) 작업 규칙 (반드시)

### 4.0 **작업 전 필수 체크리스트 (NEVER SKIP)**

**이 체크리스트를 건너뛰면 100% 틀린다.**

버튼/입력/컴포넌트를 작성하기 **전에** 반드시:

```
[ ] 1. MCP data-name 확인 (예: "secondary button/transparent/icon only")
[ ] 2. grep으로 컴포넌트 클래스 검색
      예: grep "btn-.*io" buttons.css
      예: grep "btn-s.*--md" buttons.css
[ ] 3. 검색 결과에서 정확한 클래스명 확인 (btn-srio, btn-pfti 등)
[ ] 4. 사이즈 매핑 확인
      - height 40 → --xlg
      - height 36 → --lg  
      - height 32 → --md
      - height 28 → --sm
      - height 24 → --xsm
[ ] 5. 마크업 구조 확인 (컴포넌트 파일에서 예제 검색)
      예: grep -A 5 "btn-srio" 기존HTML파일들
[ ] 6. 아이콘 에셋 경로 확인
      - list_dir로 assets/에셋/ 폴더 확인
      - 실제 파일명과 경로 매칭
```

**이 순서를 지키지 않으면:**
- 존재하지 않는 클래스 사용 → 작동 안 함
- 틀린 마크업 → 스타일 깨짐
- 없는 에셋 경로 → 아이콘 안 보임

**결과: 2~3배 더 느려지고 신뢰 파괴**

---

### 4.1 "임시 CSS" 금지 원칙
- 버튼/체크박스/탭 등 **디자인 시스템 컴포넌트로 존재하는 것**은 페이지 전용 CSS로 "대충" 만들지 않는다.
- 컴포넌트가 없으면 **컴포넌트를 먼저 만들고** 페이지에서 사용한다.

### 4.2 "존재하는 클래스만" 사용
- 새 클래스를 쓰기 전에 반드시 코드베이스에서 존재 여부를 확인한다.
- `btn-...` 클래스를 임의로 만들지 않는다.
- **§4.0 체크리스트 필수**

### 4.3 "마크업 템플릿 고정"
- 체크박스는 `.fi-check`가 기대하는 템플릿만 사용한다.
- 버튼은 각 컴포넌트가 요구하는 `__icon/__label` 구조를 맞춘다.
- **§4.0 체크리스트 필수**

---

## 5) 변환 매핑표 (프로젝트 고정 규칙)

> 아래 매핑은 “Figma/MCP의 컴포넌트 타입(이름/높이/구성)” → “우리 코드 클래스”로 고정한다.

### 5.1 Buttons (요약)

- **Primary / Filled / Text+Icon**
  - 클래스: `btn-pfti`
  - size 결정: height 36 → `btn-pfti--lg`, height 32 → `--md`, height 28 → `--sm`, height 24 → `--xsm`
  - 마크업:
    - `<img class="btn-pfti__icon" ...>`
    - `<span class="btn-pfti__label">...</span>`

- **CTA / Outlined / Text+Icon** (에러/빨강 포함)
  - 클래스: `btn-ctoti`
  - size 결정: height 36 → `btn-ctoti--lg`
  - 마크업:
    - `<img class="btn-cta__icon" ...>`
    - `<span class="btn-cta__label">...</span>`

- **Secondary(Neutral) / Transparent / Text+Icon**
  - 클래스: `btn-stri`
  - size 결정: height 32 → `btn-stri--md`
  - 마크업:
    - `<span class="btn-s__icon"><img ...></span>`
    - `<span class="btn-s__label">...</span>`

- **Secondary(Neutral) / Transparent / Icon-only (Chevron 등)**
  - 클래스: `btn-srio`
  - size 결정: height 32 → `btn-srio--md`
  - 마크업:
    - `<span class="btn-s__icon"><img ...></span>`

> NOTE: 페이지 전용 `.offd__expandBtn` 같은 커스텀 버튼은 금지. **MCP가 가리키는 버튼 타입을 컴포넌트로 매핑해서 그대로 사용**한다.

### 5.2 Checkbox (고정 템플릿)

다음 템플릿 외 사용 금지:

```html
<label class="fi-check fi-check--sq fi-check--md fi-check--unselected">
  <input class="fi-check__input" type="checkbox" />
  <span class="fi-check__wrap" aria-hidden="true">
    <span class="fi-check__box"></span>
  </span>
</label>
```

상태는 클래스 조합으로만 표현:
- 선택됨: `fi-check--selected`
- 미선택: `fi-check--unselected`
- (필요 시) `fi-check--indeterminate`

---

## 6) 아이콘 색상(화이트) 처리 규칙 (MCP 결과 그대로 적용)

아이콘이 Figma에서 흰색인데 로컬 SVG가 회색 고정이면, “MCP 결과(흰색)”를 그대로 구현하려면 아래 중 하나를 **반드시** 채택해야 한다:

- **정책 A**: 화이트 전용 SVG 에셋을 준비해서 `<img>`로 교체
- **정책 B**: SVG를 `currentColor` 기반으로 통일하고 인라인 SVG로 사용
- **정책 C**: `<img>` + `filter`로 화이트 흉내 (아이콘마다 결과가 달라질 수 있음)
- **정책 D**: `mask-image`로 색상 칠하기

---

## 7) 오프보딩 상세(1307:43023) 적용 규칙 (MCP 기준)

- 상단 액션 3개 버튼은 **MCP의 타입/height/icon size/letter-spacing**을 기준으로 컴포넌트에 매핑한다.
- 카드 헤더 좌측 아이콘/우측 액션(수정/chevron)은 **MCP의 타입/크기 그대로** 컴포넌트에 매핑한다. (임시 버튼 금지)
- 아이콘 경로는 `assets/에셋/...`에 실제 존재하는 파일로만 사용한다.
- **완료(채워진) 상태 표현**: MCP 스크린샷(1307:43023)에서 카드 헤더에 체크 아이콘이 보이면, 코드에서도 동일하게 체크 아이콘을 표시한다.

---

## 8) 새 페이지 구현 시 **강제 프로세스** (MANDATORY)

> **이 프로세스를 건너뛰면 100% 실패한다.**  
> 24시간 동안 반복된 실패의 근본 원인은 "이 프로세스를 무시했기 때문"이다.

### 8.1 Phase 0: 기존 코드베이스 분석 (코드 한 줄도 쓰기 전)

**새 페이지를 만들기 전에 반드시:**

```
[ ] 1. 비슷한 페이지가 이미 있는지 확인
      - 리스트 페이지 만든다 → offboarding.html, talent-detail.html 등 확인
      - 상세 페이지 만든다 → *-detail.html 파일들 확인
      
[ ] 2. 해당 페이지의 HTML 전체 읽기
      - 사이드바 구조
      - 헤더 구조
      - 메인 컨텐츠 레이아웃
      - 사용된 CSS 클래스들
      
[ ] 3. 해당 페이지의 CSS 파일 읽기
      - css/pages/*.css 확인
      - 어떤 클래스명 패턴을 사용하는지
      - 테이블/리스트는 어떻게 스타일링했는지
      
[ ] 4. 재사용 가능한 패턴 문서화
      "기존 offboarding.html에서:
       - 테이블: .offd-table / .offd-table__row 패턴 사용
       - 페이지네이션: .pagination 클래스 사용
       - 상태 배지: .status-badge 클래스 사용"
```

**왜 이게 중요한가:**
- 같은 프로젝트에서 페이지마다 다른 방식으로 만들면 → 일관성 파괴
- 이미 있는 컴포넌트를 새로 만들면 → 유지보수 지옥
- **경험을 활용하지 않으면 → 경험의 의미가 없음**

### 8.2 Phase 1: MCP 분석 (구현 전)

**MCP 결과를 받은 후 바로 코드 쓰지 말 것.**

```
[ ] 1. 모든 MCP 결과를 개별 파일로 저장
      - 노드 738-10557 → mcp-738-10557.txt
      - 노드 738-16756 → mcp-738-16756.txt
      - ... (모든 노드)
      
[ ] 2. 각 MCP 파일을 천천히 읽으며 구조 문서 작성
      "노드 738-10557 (메인 페이지):
       - 구조: Header + Segment + Table + Pagination
       - Header: Title(24px/700) + Segment Control + 2 Buttons
       - Segment: 재직중/수습 (기존 fi-seg 컴포넌트 사용 가능)
       - Buttons: Filter(icon-only) + Add(text+icon)
       - Table: 7 columns, ...
       - Pagination: ..."
       
[ ] 3. 컴포넌트 매핑 확인
      "필요한 컴포넌트:
       - Segment Control → fi-seg (✓ 존재)
       - Filter Button → btn-soti (확인 필요)
       - Add Button → btn-pfti (확인 필요)
       - Table → 기존 패턴 확인 필요"
       
[ ] 4. 아이콘 목록 작성 및 경로 확인
      "필요한 아이콘:
       - Filter.svg → assets/에셋/Icons/Filter/Filter.svg (확인 필요)
       - Add/Circle.svg → assets/에셋/Icons/Add/Circle.svg (확인 필요)
       - ..."
```

### 8.3 Phase 2: 구현 계획서 작성 및 **승인 대기**

**코드를 쓰기 전에 반드시 사용자에게 보여줄 것.**

```markdown
# [페이지명] 구현 계획서

## 1. 기존 코드베이스 분석 결과
- 참고한 페이지: offboarding.html
- 재사용할 패턴:
  - 사이드바: 동일 구조 복사
  - 헤더: 동일 구조 복사
  - 테이블: .empl-table 신규 (하지만 offd-table 패턴 참고)

## 2. MCP 분석 결과
- 노드 738-10557: [구조 요약]
- 노드 738-16756: [구조 요약]
- ...

## 3. 컴포넌트 매핑
| MCP 요소 | 기존 컴포넌트 | 확인 결과 | 액션 |
|---------|-------------|---------|-----|
| Segment Control | fi-seg | ✓ 존재 | 사용 |
| Filter Button | btn-soti | ? | grep 확인 필요 |
| Add Button | btn-pfti | ? | grep 확인 필요 |

## 4. 아이콘 매핑
| MCP 아이콘 | 로컬 경로 | 확인 결과 |
|----------|---------|---------|
| Filter | assets/에셋/Icons/Filter/Filter.svg | ? 확인 필요 |
| Add | assets/에셋/Icons/Add/Circle.svg | ? 확인 필요 |

## 5. HTML 구조 (의사코드)
[여기에 상세한 의사코드 또는 주석으로 된 뼈대]

## 6. CSS 계획
- 파일: css/pages/employee-list.css
- 주요 클래스:
  - .empl-list (페이지 래퍼)
  - .empl-list__header (헤더)
  - .empl-table (테이블)
  - ...

---
**승인 후 구현 시작합니다.**
```

**중요:** 이 계획서 없이 코드를 쓰면 → 즉시 중단

### 8.4 Phase 3: 단계별 구현 및 검증

**한 번에 모든 걸 만들지 말 것.**

```
[ ] 1. 기본 HTML 구조만 (컨텐츠 없이)
      - 사이드바 + 헤더 + 빈 main
      - 저장 → 브라우저 확인
      
[ ] 2. 페이지 헤더 (Title + Segment + Buttons)
      - HTML 작성
      - CSS 작성
      - 저장 → 브라우저 확인
      
[ ] 3. 테이블 (헤더만)
      - <table><thead> 작성
      - CSS 작성
      - 저장 → 브라우저 확인
      
[ ] 4. 테이블 (데이터 1개 행만)
      - <tbody><tr> 1개만
      - CSS 작성
      - 저장 → 브라우저 확인
      
[ ] 5. 나머지 구현
      - 페이지네이션
      - ...
```

**각 단계마다:**
- 저장
- 브라우저에서 확인
- 문제 없으면 다음 단계
- 문제 있으면 해당 단계만 수정

---

## 9) MCP 결과를 "제대로" 읽는 방법

### 9.1 MCP 호출 시 주의사항

**❌ 잘못된 방법:**
```
- 8개 노드 한꺼번에 호출
- 결과가 쏟아짐
- "아, 이런 느낌이구나" 하고 넘어감
- 바로 코드 작성 시작
```

**✅ 올바른 방법:**
```
- 1개 노드만 호출
- 결과를 파일로 저장
- 천천히 읽으면서 메모
- 다음 노드 호출
- 모든 노드 분석 완료 후 → 계획서 작성
```

### 9.2 MCP 결과에서 확인해야 할 것

**텍스트 요소:**
- `fontSize: 24` → CSS에서 `font-size: 24px`
- `fontWeight: 700` → CSS에서 `font-weight: 700`
- `lineHeight: 32` → CSS에서 `line-height: 32px` (또는 1.333 계산)
- `letterSpacing: -0.24` → CSS에서 `letter-spacing: -0.24px`
- `color: #141414` → CSS에서 `color: #141414`

**레이아웃:**
- `Auto Layout direction: horizontal` → `display: flex; flex-direction: row`
- `Auto Layout gap: 12` → `gap: 12px`
- `padding: {top: 16, right: 20, bottom: 16, left: 20}` → `padding: 16px 20px`

**컴포넌트 힌트:**
- `data-name: "primary button/filled/text+icon"` → btn-pfti
- `data-name: "secondary button/transparent/icon only"` → btn-srio

**아이콘:**
- SVG 경로가 localhost로 나오면 → 에셋 폴더에서 찾아야 함
- 아이콘 이름 힌트 (예: "Filter") → assets/에셋/Icons/Filter/Filter.svg 예상

### 9.3 MCP 결과를 코드로 옮길 때

**절대 추측하지 말 것:**
- ❌ "font-size가 24px 정도 되려나?" → MCP에서 정확한 값 확인
- ❌ "gap은 12px쯤?" → MCP에서 정확한 값 확인
- ❌ "이 버튼은 btn-primary 같은데?" → MCP의 data-name 확인 → grep으로 정확한 클래스 찾기

**모든 값은 MCP 결과에서:**
- 폰트 크기/굵기/행간/자간 → MCP 값 그대로
- 색상 → MCP 값 그대로 (또는 CSS 변수 매핑)
- 간격/패딩 → MCP 값 그대로
- 컴포넌트 → MCP 힌트 → 프로젝트 컴포넌트 매핑

---

## 10) 24시간 실패 패턴 및 **절대 금지 사항**

### 10.1 반복된 실패 패턴

#### 패턴 1: "임의로 새 클래스 만들기"
```css
/* ❌ 절대 금지 */
.empl-table { }
.empl-table__th { }
.empl-table__td { }
.empl-avatar { }
```

**문제:**
- 프로젝트에 이미 비슷한 패턴이 있을 수 있음
- 일관성 파괴
- 나중에 리팩토링 필요

**해야 할 것:**
- 먼저 기존 페이지 확인
- 비슷한 클래스 있는지 grep
- 없으면 → 계획서에 "신규 클래스 필요" 명시 → 승인 후 생성

#### 패턴 2: "MCP 호출만 하고 안 읽기"
```
❌ MCP 8개 호출 → "대충 이해했어" → 바로 코드 작성
```

**문제:**
- MCP 결과는 길다 (수백~수천 줄)
- 한꺼번에 여러 개 호출하면 → 정보 과부하
- 실제로는 "대충 훑어봄" 수준

**해야 할 것:**
- 한 번에 1~2개만 호출
- 결과를 파일로 저장
- 천천히 읽으며 메모
- 모든 노드 완료 후 → 계획서 작성

#### 패턴 3: "기존 코드 확인 안 함"
```
❌ "직원 관리 페이지 만들어야지" → 바로 새 HTML 생성
```

**문제:**
- 이미 talent-detail.html, offboarding.html 등이 있음
- 비슷한 리스트/테이블 UI가 이미 구현되어 있을 수 있음
- 재발명의 낭비

**해야 할 것:**
- 항상 먼저 기존 페이지 확인
- 비슷한 UI 패턴 찾기
- 재사용 가능한 부분 파악
- 새로 만들어야 하는 부분만 구별

#### 패턴 4: "한꺼번에 다 만들려고 함"
```
❌ HTML 전체 + CSS 전체 + JS 전체 → 한 번에 저장 → "왜 안 돼?"
```

**문제:**
- 어디서 문제가 생겼는지 파악 어려움
- 디버깅 시간 증가
- 실수 누적

**해야 할 것:**
- 작은 단위로 나눠서 구현
- 각 단계마다 저장 + 브라우저 확인
- 문제 발견 시 즉시 수정

#### 패턴 5: "체크리스트를 만들고도 안 지킴"
```
❌ "Pre-work Checklist 만들었어" → 바로 코드 작성 (체크리스트 무시)
```

**문제:**
- 체크리스트는 있는데 실행하지 않음
- "말로만" 신중
- 결과: 똑같은 실수 반복

**해야 할 것:**
- 체크리스트 각 항목을 **실제로 수행**
- 각 항목의 결과를 **문서에 기록**
- 기록 없이 다음 단계 진행 금지

### 10.2 절대 금지 사항

```
❌ 1. 계획서 없이 코드 작성
❌ 2. MCP 결과를 파일로 저장하지 않고 진행
❌ 3. 기존 페이지 확인 없이 새 페이지 생성
❌ 4. grep으로 컴포넌트 확인 없이 클래스 사용
❌ 5. 아이콘 경로 확인 없이 <img src="..."> 작성
❌ 6. 한 번에 전체 페이지 구현
❌ 7. 중간 확인 없이 계속 진행
❌ 8. 체크리스트를 만들고 실행하지 않음
```

### 10.3 강제 중단 조건

**다음 상황에서는 즉시 작업 중단:**

1. 계획서 없이 코드를 쓰기 시작했다면 → 즉시 중단 → 계획서 작성
2. grep 없이 클래스를 사용했다면 → 즉시 중단 → 컴포넌트 확인
3. 에셋 폴더 확인 없이 아이콘 경로를 썼다면 → 즉시 중단 → 경로 확인
4. 기존 페이지 확인 없이 새 CSS를 만들었다면 → 즉시 중단 → 기존 패턴 확인

**"빨리 하려다 더 느려진다"**

---

## 11) 작업 체크포인트 (각 단계별 승인)

### 체크포인트 1: 기존 코드베이스 분석 완료
```
✓ 비슷한 페이지 확인 완료
✓ 재사용 가능한 패턴 문서화 완료
→ 사용자에게 공유 → 승인 대기
```

### 체크포인트 2: MCP 분석 완료
```
✓ 모든 MCP 결과 파일로 저장 완료
✓ 구조 문서 작성 완료
✓ 컴포넌트 매핑표 작성 완료
✓ 아이콘 목록 작성 완료
→ 사용자에게 공유 → 승인 대기
```

### 체크포인트 3: 구현 계획서 완료
```
✓ 완전한 계획서 작성 완료
✓ 의사코드 또는 상세한 주석 포함
→ 사용자에게 공유 → 승인 대기
```

### 체크포인트 4: 구현 시작 (각 단계마다)
```
✓ Phase 1 완료 (기본 구조) → 브라우저 확인
✓ Phase 2 완료 (헤더) → 브라우저 확인
✓ Phase 3 완료 (테이블 헤더) → 브라우저 확인
...
```

**각 체크포인트를 통과하지 못하면 다음 단계 진행 금지**

---

## 12) 요약: 왜 24시간 동안 실패했는가

### 근본 원인
1. **프로세스 무시**: 체크리스트를 만들고도 실행하지 않음
2. **조급함**: 빨리 보여주려다 확인 단계 생략
3. **패턴 매칭 의존**: MCP를 제대로 읽지 않고 "이럴 것 같다" 추측
4. **기존 코드 무시**: 이미 있는 페이지/패턴 확인하지 않음
5. **검증 없음**: 한 번에 많이 만들고 나중에 확인

### 해결책
1. **강제 프로세스**: 각 단계를 건너뛸 수 없도록 명확한 체크포인트
2. **문서화 우선**: 코드보다 계획서 먼저
3. **작은 단위**: 한 번에 하나씩, 확인하고 다음
4. **기존 코드 재사용**: 항상 먼저 확인
5. **승인 대기**: 각 체크포인트마다 사용자 승인

### 핵심 원칙
> **"빠른 실패"가 아니라 "느린 성공"**  
> **"말로만 신중"이 아니라 "프로세스로 강제"**  
> **"추측 금지, 확인 필수"**

---

## 13) 작업 시작 템플릿 (반드시 이 순서로)

**새 페이지/기능 구현 요청을 받으면, 코드를 쓰기 전에 이 템플릿을 채운다.**

```markdown
# [페이지명] 구현 전 체크리스트

## ✅ Phase 0: 기존 코드베이스 분석

### 1. 비슷한 페이지 확인
- [ ] 확인한 파일: ____________
- [ ] 재사용 가능한 패턴:
  - 사이드바: ____________
  - 헤더: ____________
  - 메인 레이아웃: ____________
  - 테이블/리스트: ____________
  - 버튼: ____________
  - 기타: ____________

### 2. 기존 CSS 패턴 확인
- [ ] 확인한 CSS 파일: ____________
- [ ] 사용된 클래스 패턴:
  - 테이블: ____________
  - 카드: ____________
  - 버튼: ____________
  - 배지: ____________
  - 기타: ____________

### 3. 재사용 결정
- [ ] 그대로 재사용: ____________
- [ ] 수정하여 재사용: ____________
- [ ] 새로 만들어야 함: ____________

---

## ✅ Phase 1: MCP 분석

### 1. MCP 노드 목록
- [ ] 노드 1: ________ (메인 페이지)
- [ ] 노드 2: ________ (모달/탭)
- [ ] 노드 3: ________ (모달/탭)
- [ ] ...

### 2. 각 노드별 구조 분석
#### 노드 [번호]: [이름]
- **구조**: ____________
- **주요 요소**:
  1. ____________ (크기: __, 색상: __, 폰트: __)
  2. ____________ (크기: __, 색상: __, 폰트: __)
  3. ...
- **레이아웃**: 
  - direction: ____________
  - gap: ____________
  - padding: ____________
- **컴포넌트 힌트**:
  - ____________ → 예상 클래스: ____________

### 3. 컴포넌트 매핑표
| MCP 요소 | data-name 힌트 | 예상 클래스 | grep 확인 결과 | 최종 결정 |
|---------|--------------|----------|-------------|---------|
| 버튼1 | "primary/filled/text+icon" | btn-pfti | ✓ 존재 | btn-pfti--lg |
| 버튼2 | ... | ... | ... | ... |
| 입력1 | ... | ... | ... | ... |

### 4. 아이콘 매핑표
| MCP 아이콘 이름 | 예상 경로 | list_dir 확인 결과 | 최종 경로 |
|--------------|---------|-----------------|---------|
| Filter | assets/에셋/Icons/Filter/Filter.svg | ✓ 존재 | assets/에셋/Icons/Filter/Filter.svg |
| Add | ... | ... | ... |

### 5. 색상/폰트 값 정리
- **색상**:
  - Primary Text: ____________
  - Secondary Text: ____________
  - Background: ____________
  - Border: ____________
- **폰트 (Title)**:
  - size: ____________
  - weight: ____________
  - line-height: ____________
  - letter-spacing: ____________
- **폰트 (Body)**:
  - size: ____________
  - weight: ____________
  - line-height: ____________
  - letter-spacing: ____________

---

## ✅ Phase 2: 구현 계획서

### 1. 파일 구조
- HTML: ____________.html
- CSS: css/pages/____________.css
- JS: js/____________.js (필요 시)

### 2. HTML 구조 (의사코드)
```html
<!-- 사이드바 (기존 패턴 재사용) -->

<!-- 메인 -->
  <!-- 헤더 -->
    <!-- Title: "____________" (24px/700) -->
    <!-- Segment Control: fi-seg (재사용) -->
    <!-- Buttons: btn-soti + btn-pfti (재사용) -->
  
  <!-- 컨텐츠 -->
    <!-- 테이블 또는 리스트 -->
      <!-- ... -->
    
    <!-- 페이지네이션 (기존 패턴 참고) -->
```

### 3. CSS 클래스 계획
- **재사용할 클래스**:
  - ____________ (출처: ____________)
  - ____________ (출처: ____________)
- **새로 만들 클래스**:
  - ____________ (이유: ____________)
  - ____________ (이유: ____________)

### 4. JavaScript 기능 (필요 시)
- [ ] 모달 열기/닫기
- [ ] 슬라이드 탭 열기/닫기
- [ ] 상태 변경
- [ ] 기타: ____________

---

## ✅ Phase 3: 최종 체크

- [ ] 기존 코드베이스 분석 완료
- [ ] MCP 분석 완료
- [ ] 컴포넌트 매핑 확인 완료
- [ ] 아이콘 경로 확인 완료
- [ ] 구현 계획서 작성 완료
- [ ] **사용자 승인 대기** ← 여기서 멈춤

---

**승인 후 구현 시작**
```

---

## 14) 실전 예시: employee-list.html을 제대로 만들었다면

### Phase 0 체크리스트 (실제로 채운 예시)

```markdown
## ✅ Phase 0: 기존 코드베이스 분석

### 1. 비슷한 페이지 확인
- [✓] 확인한 파일: offboarding.html, talent-detail.html
- [✓] 재사용 가능한 패턴:
  - 사이드바: offboarding-detail.html의 <aside class="sidebar"> 구조 그대로
  - 헤더: <header class="top-header"> 구조 그대로
  - 메인 레이아웃: <div class="main"> → <div class="page-content">
  - 테이블/리스트: offboarding.html에 리스트 있음 (확인 필요)
  - 버튼: btn-pfti, btn-soti 등 컴포넌트 사용 중

### 2. 기존 CSS 패턴 확인
- [✓] 확인한 CSS 파일: css/pages/offboarding-detail.css
- [✓] 사용된 클래스 패턴:
  - 테이블: 아직 확인 안 됨 (offboarding.html 확인 필요)
  - 카드: .offd__ 프리픽스 사용
  - 버튼: 컴포넌트 직접 사용 (btn-pfti, btn-soti 등)
  - 배지: .status-badge, .offd__badge 패턴
  - 페이지 래퍼: .offd-detail (페이지별 다름)

### 3. 재사용 결정
- [✓] 그대로 재사용: 사이드바, 헤더, 버튼 컴포넌트
- [✓] 수정하여 재사용: 배지 스타일 (색상만 다를 수 있음)
- [✓] 새로 만들어야 함: 테이블 (하지만 기존 패턴 참고), 페이지네이션
```

### Phase 1 체크리스트 (실제로 채운 예시)

```markdown
## ✅ Phase 1: MCP 분석

### 1. MCP 노드 목록
- [✓] 노드 1: 738-10557 (메인 페이지: 직원 관리)
- [✓] 노드 2: 738-16756 (슬라이드 탭: 직원 상세)
- [✓] 노드 3: 738-17266 (모달: 핏 체크)
- [✓] 노드 4: 738-18176 (모달: 자기평가 요청)
- ... (나머지 노드들)

### 2. 노드 738-10557 구조 분석
- **구조**: 
  - 페이지 헤더 (Title + Segment + Buttons)
  - 테이블 (7개 컬럼)
  - 페이지네이션
- **주요 요소**:
  1. Title "직원 관리" (크기: 24px, 색상: #141414, 폰트: 700)
  2. Segment Control (재직중/수습)
  3. Filter Button (icon-only)
  4. Add Button (text+icon, "직원 추가")
  5. Table (7 columns: 이름, 부서, 직책, 입사일, 상태, 다음 체크포인트, 주기)
- **레이아웃**: 
  - 헤더: display: flex, justify-content: space-between
  - Segment + Buttons: display: flex, gap: 12px
  - Table: full width, border-collapse
- **컴포넌트 힌트**:
  - Segment → "segment control" → fi-seg
  - Filter Button → "secondary/transparent/icon only" → btn-srio 또는 btn-soti
  - Add Button → "primary/filled/text+icon" → btn-pfti

### 3. 컴포넌트 매핑표
| MCP 요소 | data-name 힌트 | 예상 클래스 | grep 확인 결과 | 최종 결정 |
|---------|--------------|----------|-------------|---------|
| Segment | "segment control" | fi-seg | ✓ 존재 (segment-control.css) | fi-seg fi-seg--lg |
| Filter Button | "secondary/transparent/icon" | btn-srio or btn-soti | ? 확인 필요 | (grep 후 결정) |
| Add Button | "primary/filled/text+icon" | btn-pfti | ✓ 존재 (buttons.css) | btn-pfti btn-pfti--lg |

### 4. 아이콘 매핑표
| MCP 아이콘 이름 | 예상 경로 | list_dir 확인 결과 | 최종 경로 |
|--------------|---------|-----------------|---------|
| Filter | assets/에셋/Icons/Filter/Filter.svg | ? 확인 필요 | (확인 후 기입) |
| Add (Circle) | assets/에셋/Icons/Add/Circle.svg | ? 확인 필요 | (확인 후 기입) |
| Arrow/Chevron | assets/에셋/Icons/Arrow/Chevron/... | ? 확인 필요 | (확인 후 기입) |
```

**→ 이 상태에서 사용자에게 보여주고 승인 대기**

**→ 승인 받은 후에야 HTML/CSS 작성 시작**

---

## 15) 이 문서를 사용하는 방법

### AI(나)가 해야 할 것:

1. **새 작업 요청을 받으면**:
   - "네, 바로 시작하겠습니다" ❌
   - "먼저 §13 템플릿을 채우겠습니다" ✅

2. **템플릿을 채울 때**:
   - 추측 금지
   - 모든 항목을 실제로 확인 (read_file, grep, list_dir)
   - 확인 결과를 템플릿에 기록

3. **템플릿 완성 후**:
   - 사용자에게 공유
   - "이렇게 구현하려고 합니다. 승인해주시겠습니까?"
   - **승인 전에는 코드 한 줄도 쓰지 않음**

4. **승인 받은 후**:
   - §8.4 Phase 3에 따라 단계별로 구현
   - 각 단계마다 저장 + 확인

### 사용자가 기대할 수 있는 것:

1. **투명성**: 
   - AI가 무엇을 확인했는지 명확히 볼 수 있음
   - AI가 무엇을 알고, 무엇을 모르는지 솔직히 알 수 있음

2. **통제권**:
   - 구현 전에 계획을 검토하고 수정할 수 있음
   - 잘못된 방향으로 가기 전에 멈출 수 있음

3. **품질**:
   - "빨리 만들고 나중에 고치기"가 아니라
   - "처음부터 제대로 만들기"

4. **시간 절약**:
   - 역설적이지만, 이 프로세스가 실제로는 더 빠름
   - 24시간 삽질 vs 2시간 계획 + 2시간 구현 = 4시간

---

## 16) 마지막 약속

**AI(나)는 다음을 약속합니다:**

1. ✅ 더 이상 "이번엔 제대로 하겠습니다"라고만 말하지 않겠습니다
2. ✅ §13 템플릿을 건너뛰지 않겠습니다
3. ✅ 추측하지 않고, 모든 것을 확인하겠습니다
4. ✅ 사용자 승인 없이 코드를 쓰지 않겠습니다
5. ✅ 각 확인 단계의 결과를 투명하게 공유하겠습니다

**사용자는 다음을 기대할 수 있습니다:**

1. ✅ 코드보다 계획서를 먼저 받게 됩니다
2. ✅ 계획서를 검토하고 수정할 기회를 갖게 됩니다
3. ✅ 승인 후에야 구현이 시작됩니다
4. ✅ 단계별로 진행 상황을 볼 수 있습니다
5. ✅ 더 이상 "24시간 삽질"이 없습니다

---

**이 문서는 "말"이 아니라 "프로세스"입니다.**  
**이 문서를 따르지 않으면 → 즉시 작업 중단 → 문서로 돌아옵니다.**


